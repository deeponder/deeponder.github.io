---
layout:     post
title:      leetcode
subtitle:   
date:       2019-12-28
author:     jabin
header-img: 
catalog: true
tags:
    - 计算机
    - leetcode
---

# 一、字符串
1. 基本上都需要循环遍历，来解决
2. 思路想清楚，再动手

## 1.1 最长公共前缀
```
// 查找最短的字符串
func getShortestStr(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    
    shortestStr := strs[0]
    
    // 遍历、替换
    for _, v:= range strs {
        if len(v) < len(shortestStr) {
            shortestStr = v
        }
    }
    
    return shortestStr
}

func longestCommonPrefix(strs []string) string {
    // 1. 查找最短字符串
    shortestStr := getShortestStr(strs)
    // 2. 遍历最短字符串
    for i, v := range shortestStr {
        
        // 3. 遍历字符串数组
        for _, str := range strs {
            // 4. 第一次出现字符不一致， 直接返回
            if str[i] != byte(v) {
                return shortestStr[0:i]
            }
        }
        
        
    }
    
    // 5. 返回最短字符串
    return shortestStr
}
```

## 1.2 罗马数字转整数
```
func romanToInt(s string) int {
    // 1. 定义罗马单字和数字映射map
    valueMap := map[byte]int {
        'I':1,
        'V':5,
        'X':10,
        'L':50,
        'C':100,
        'D':500,
        'M':1000,
    }
    
    num := 0  // 统计计数和
    // 2. 遍历罗马数字
    for i, v := range s {
        curNum := valueMap[byte(v)]
        // 3. 若当前数字>=下个数字或是最后一个了，加， 否则减
        if  i==len(s)-1 || curNum >= valueMap[s[i+1]] {
            num += curNum 
        } else {
            num -= curNum 
        }
                
    }
    
    return num
}
```

## 1.3 外观数列
```
func countAndSay(n int) string {
    // 1. 循环每一行
    // 2. 通过循环上一行，进行计数，得到下一行
    str := "1"
    for i:=1; i<n; i++ {
        tmp := ""
        lenStr := len(str)
        for j:=0; j<lenStr; j++ {
            count := 1
            for ; j+1<lenStr && str[j] == str[j+1]; {
                count++
                j++
            }

            
            tmp = tmp + strconv.Itoa(count) + string(str[j])
            //tmp = append(tmp, str[j])
        }

        str = tmp
    }

    return str
}
```

## 1.4 字符串中第一个唯一字符
```
func firstUniqChar(s string) int {
 	var charCntMap = make(map[rune]int, 0)
 	// 1. 对所有的字符进行计数，存进map
 	for _, v := range s {
 		if _, ok := charCntMap[v]; ok { // 若存在，则计数加1
 			charCntMap[v]++
        } else {  // 若不在， 则置为1
            charCntMap[v] = 1
        }
 	}
    
    
 	// 2. 遍历字符串， 找第一个计数为1
 	for i, v := range s {
        if charCntMap[v] == 1 {
            return i
        }
 	}

 	return -1
}
```

## 1.5 翻转字符串
```
func reverseString(s []byte)  {
	// 一个循环， 两个方向向中间移动，进行两两交换
	for i, j := 0, len(s)-1; i<j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	} 
}
```

## 1.6 验证回文串
```
func isPalindrome(s string) bool {
	// 1. 字符串预处理
	// 转成小写
	s = strings.ToLower(s)
	// 去除非数字Or字母的
	resStr := ""
	for _, v := range s {
		if (rune(v) >= 'a' && rune(v) <= 'z') || (rune(v) >= '0' && rune(v) <= '9') {
			resStr += string(v)
		}
	}
	// 2. 两边往中间遍历, 判断是否都相等
	for i, j:=0, len(resStr)-1; i<j; i,j = i+1, j-1 {
		if (resStr[i] != resStr[j]) {
			return false
		}
	}

	return true
}
```

## 1.7 有效的括号
```
// 配对，利用栈的先进后出
func isValid(s string) bool {
    // 栈，左括号进栈，右括号出栈，并且是否相匹配，最后判断是否空栈
    // 1. 定义左右括号的映射 和 栈
    bracketMap := map[rune]rune {
    	'}':'{',
    	']':'[',
    	')':'(',
    }
    
    stack := make([]rune, 0)

    // 2. 循环字符串
    for _, v := range s {
    	switch rune(v) {
            case '{', '(', '[':
                // 左括号都入栈
                stack = append(stack, rune(v))
            case '}', ')', ']':
                // 右括号判断是否是空栈， 或者是否和栈顶字符相等
                if len(stack) == 0 || bracketMap[rune(v)] != stack[len(stack)-1] {
                    return false
                }
                stack = stack[:len(stack)-1]
            default:
                return false
        }
    }

    // 3. 若栈不为空， 说明还有未匹配的， 返回false
    if (len(stack)>0) {
    	return false
    }

    return true

}
```

## 1.7 实现strStr
```
func strStr(haystack string, needle string) int {
	if len(needle) == 0 {
		return 0
	}
	// 1. 循环haystack， 若和needle的第一个字符一样，则遍历needle， 若不一样，则break，若都一样， 则返回i
	for i, v := range haystack {
		if v == rune(needle[0]) {
			j := i
			for _, v2 := range needle {
				if j> len(haystack)-1 || v2 != rune(haystack[j]) {
					break
				}
				j++
			}

			//2. 若遍历完了needle， 则找到了
			if len(needle) == j-i {
				return i
			}
		}
	}

	return -1   
}
```

## 1.8 最长回文子串
```
func isPalindrome(s string) bool {
	for i, j:=0, len(s)-1; i<j; i,j = i+1, j-1 {
		if (s[i] != s[j]) {
			return false
		}
	}

	return true
}

func longestPalindrome(s string) string {
    // 1. 从s的最大长度开始遍历，寻找满足的子回文串
    lenStatic := len(s)
    lenS := len(s)
    for lenS > 0 {
    	for i:=0; i<=lenStatic-lenS;i++ {
    		if isPalindrome(s[i:i+lenS]) {
    			return s[i:i+lenS]
    		}
    	}

    	lenS--
    }

    return ""
}
```

# 二、数组
## 2.1 买卖股票最佳时机
```
func maxProfit(prices []int) int {
	// 遍历每天的股票价格，统计收益，若收益小于0重置，否则判断当前迭代的收益是否大于当前最大收益，大则更新最大收益
	maxProfit := 0
	tmpProfit := 0

	// 1. 若只有一天的价格， 则返回0
	if len(prices) < 2 {
		return 0
	}

	// 2. 遍历股票价格
	for i:=1; i<len(prices); i++ {
		// 每天的收益
		dayProfit := prices[i] - prices[i-1]
		// 更新tmpProfit
		tmpProfit = tmpProfit + dayProfit

		// 3. 若tmpProfit<0了， 则重置为0， 不操作
		if tmpProfit < 0 {
			tmpProfit = 0
		}

		// 4. 若tmpProfit 大于max了， 则更新
		if tmpProfit > maxProfit {
			maxProfit = tmpProfit
		}
	}


	return maxProfit  
}
```

## 2.2 最长子序和
```
func maxSubArray(nums []int) int {
	// 遍历数组，贪婪算法
	maxSum := nums[0]
	tmpSum := 0
	// 1. 遍历数组
	for _, num range nums {
		// 2. 不管啥，直接要, 要完判断是否更新max
		tmpSum += num
		if tmpSum > maxSum {
			maxSum = tmpSum
		}

		// 3. 本来有0， 加了还少了。。重新来
		if tmpSum < 0 {
			tmpSum = 0
		}
	}

    return maxSum
}
```

## 2.3 两数之和
```
func twoSum(nums []int, target int) []int {
	// 一个循环， map记录当前值对应的下标，判断target减去当前遍历的下标的下标是否为空
	idxMap := make(map[int]int, 0)

	for i, v := range nums {
		if _, ok := idxMap[target-v]; ok {
   			return []int{i, idxMap[target-v]}
   		}
   		idxMap[v] = i
	}
   
  	return nil
}
```

## 2.4 合并两个有序数组
```
func merge(nums1 []int, m int, nums2 []int, n int)  {
    // 1、直接从最大的开始赋值
    i := m-1
    j := n-1
    k := m+n-1
    for i>=0 && j>=0 {
    	if nums1[i] > nums2[j] {
    		nums1[k] = nums1[i]
    		i--
    	} else {
    		nums1[k] = nums2[j]
    		j--
    	}

    	k--
    }

    // 2. 若nums2还有，则直接给num1最前面
    for j >= 0 {
    	nums1[k] = nums2[j]
    	j--
    	k--
    }
}
```

## 2.5 盛最多水的容器
```
func maxArea(height []int) int {
    max := 0
    tmp := 0

    i:=0
    j:= len(height)-1
    for i < j {
        if height[i] < height[j] {
            tmp = height[i] * (j-i)
            i++
        } else {
            tmp = height[j] * (j-i)
            j--
        }
        if tmp > max {
            max = tmp
        }
    }
    return max
}
```

# 三、链表
## 3.1 反转链表
```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var pre *ListNode
    var cur *ListNode
    var tmp *ListNode

    cur = head


    for cur != nil {

    	tmp = cur.Next

    	cur.Next = pre
    	pre = cur
    	

    	cur = tmp
    }


    return pre
}
```

## 3.2 合并两个有序链表
```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    } 

    if l2 == nil {
        return l1
    }

    var head *ListNode
    var tmpNode *ListNode
    // 开始
    if l1.Val <= l2.Val {
    	tmpNode = l1
    	l1 = l1.Next
    } else {
    	tmpNode = l2
    	l2 = l2.Next
    }

    head = tmpNode 

    // 循环两个链表， 比较， 加入tmpNode, 各自有自己的计数器
    for l1 != nil && l2 != nil {
    	if l1.Val <= l2.Val {
    		tmpNode.Next = l1
    		l1 = l1.Next
    	} else {
    		tmpNode.Next = l2
    		l2 = l2.Next
    	}

    	tmpNode = tmpNode.Next
    }

    // 还有剩下的，直接到后面
    if l1 != nil {
    	tmpNode.Next = l1
    }

    if l2 != nil {
    	tmpNode.Next = l2
    }

    return head

}
```

## 3.3 两数相加
```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    head := &ListNode{Val:0}

    tmp := head

    flag := false
    // 1. 遍历 l1, l2, 直到有一个穷尽了
    for l1 != nil && l2 != nil {
    	var sum int
    	if flag {
    		sum = l1.Val + l2.Val + 1
    	} else {
    		sum = l1.Val + l2.Val
    	
    	}

    	// 若大于10 ， 则置flag为true
    	if sum >= 10 {
    		flag = true
    		sum = sum - 10
    	} else {
    		flag = false
    	}
    	tmpNode := &ListNode {
    		Val : sum,
    	}
    	
    	tmp.Next = tmpNode

    	tmp = tmp.Next


    	// 迭代
        l1 = l1.Next
        l2 = l2.Next
    }

    // 2. 处理剩下的
    if l1 != nil {
    	tmp.Next = l1
    }

    if l2 != nil {
    	tmp.Next = l2
    }

    if l1 == nil && l2 == nil {
    	if flag {
    		tmp.Next = &ListNode {
    			Val:1,
    		}
    	}
    }

    return head.Next
}
```

# 四、动态规划

# 五、树

# 六、深度/广度优先

# 七、设计题
## 7.1 LRU缓存机制
```
// 1. 操作： Get， set
// 2. 双向链表, 忽略首尾节点

// 定义双向链表的节点
type ListNode struct {
	Val int
	Key int
	Pre *ListNode
	Next *ListNode
}

type LRUCache struct {
	Cap int
	Len int 
	Map map[int]*ListNode  // 做一个映射， O(1)复杂度get
	Head *ListNode
	Tail *ListNode
}


func Constructor(capacity int) LRUCache {
	cache := LRUCache {
		Cap : capacity, 
		Len : 0,
		Map : make(map[int]*ListNode, capacity), 
		Head : &ListNode{}, 
		Tail : &ListNode{}, 
	}

	cache.Head.Next = cache.Tail
	cache.Tail.Pre = cache.Head

	return cache
}

// 指定的node, 加到队首
func (this *LRUCache) addToHead(listNode *ListNode) {
	listNode.Next = this.Head.Next
	this.Head.Next.Pre = listNode
	this.Head.Next = listNode
	listNode.Pre = this.Head

	this.Len++
}

// 删除
func (this *LRUCache) removeNode(listNode *ListNode) {
	listNode.Pre.Next = listNode.Next
	listNode.Next.Pre = listNode.Pre
	this.Len--
}

// 把指定的Key 移到队首, 
func (this *LRUCache) moveToHead(listNode *ListNode) {
	this.removeNode(listNode)
	this.addToHead(listNode)
}


func (this *LRUCache) Get(key int) int {
	// 1. 不存在， 返回-1
	// 2. key存在，返回，并放到队首
	if _, ok := this.Map[key]; !ok {
		return -1
	}

	this.moveToHead(this.Map[key])
	return this.Map[key].Val

}

func (this *LRUCache) Put(key int, value int)  {
	// 1. 存在， 移到队首
	// 1. 不存在容量够， 则加到队首
	// 2. 不存在容量不够， 则删除队尾的Key, 再加到队首
	if _, ok := this.Map[key]; ok {
		this.Map[key].Val = value
		this.moveToHead(this.Map[key])
		return 
	}

	node := &ListNode{Val:value, Key: key}

	if this.Len >= this.Cap {
		delete(this.Map, this.Tail.Pre.Key)
		this.removeNode(this.Tail.Pre)
	}
	// 加到Map
	this.Map[key] = node
	this.addToHead(node)
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */

```

# 八、数学类型题
## 8.1 整数反转
```
func reverse(x int) int {
    result := 0
    // 循环移位, 由低位往高位构造整数
    for x != 0 {
    	result = result * 10 + x%10

    	x /= 10
    }

    if result<math.MaxInt32 && result>math.MinInt32 {
    	return result
    }

    return 0
}
```
